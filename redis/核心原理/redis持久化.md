5W2H

Why:为什么需要持久化

What:什么是redis的持久化

Where:持久化在哪里

When: 何时触发持久化

Who: redis做持久化的是工作线程还是后台线程

How:如何持久化的

How much:持久化的消耗是什么





### 为什么Redis需要持久化

1. redis是内存数据库，宕机后数据会消失
2. redis重启后快速恢复数据，要提供持久化机制
3. redis持久化是为了快速恢复数据而不是为了存储数据
4. redis主从复制依赖持久化



注意：redis的持久化不保证数据的完整性

当redis用作DB时，DB数据要完整，所以一定要有一个完整的数据源（文件、mysql）

在系统启动时，从这个完整的数据源中将数据load到Redis中

数据量较小，不易改变，比如：字典库（XML,Table）





### redis如何实现持久化的

redis的持久化方式有两种：

1. RDB (Redis DataBase)
2. AOF (Append Only File)



##### RDB

RDB（Redis DataBase），是redis**默认**的存储方式，RDB方式是通过**快照**（snapshotting）完成的。只关注这一时刻的数据，不关注如何生成数据的。



**如何实现的**

Redis会通过fork函数创建一个**子进程**来完成数据的持久化





**何时会持久化**

触发RDB的方式有：

1. 符合自定义配置的快照配置
2. 执行save或者bgsave命令
3. 执行flushall命令
4. 执行主从复制操作（第一次）



**配置参数定期执行**

在redis.conf中配置：save       多少秒数据变了多少

```shell
save "" # 不使用RDB存储 不能主从
save 900 1 # 标识15分钟（900秒钟）内至少有1个键被更改则进行快照
save 300 100 # 标识5分钟(300秒) 内至少100个键被更改则进行快照
save 60 10000 # 标识1分钟内至少有10000个键被更改则进行快照
```



**命令显示触发**

在客户端输入bgsave命令



**RDB的执行流程（原理）**

![image-20221011171540571](redis持久化.assets/image-20221011171540571.png)

1. Redis父进程首先判断:当前是否有子进程在执行持久化任务，如果在执行bgsave命令时直接返回。
2. 父进程执行**fork**（调用OS函数复制主进程）操作创建子进程，这个复制过程中**父进程是阻塞的**，redis不能响应来自客户端的命令。
3. 父进程fork后，bgsave命令返回“Background saving started”信息并不再阻塞父进程，并可以响应其他命令。
4. 子进程创建RDB文件，根据**父进程内存快照**生成临时快照文件，文件生成后对原有文件进行替换。
5. 子进程发送信号给父进程标识完成，父进程更新统计信息。



**RDB文件格式**

![image-20221011173501517](redis持久化.assets/image-20221011173501517.png)

1. 头部5个字节固定为“REDIS”字符串

2. 4字节“RDB”版本号（不是Redis版本号),当前8，填充后为0008

3. 辅助字段，以key-value的形式

   | 字段名     | 字段值     | 字段名         | 字段值      |
   | ---------- | ---------- | -------------- | ----------- |
   | Redis-ver  | 5.0.5      | aof-preamble   | 是否开启aof |
   | redis-bits | 64/32      | repl-stream-db | 主从复制    |
   | ctime      | 当前时间戳 | repl-id        | 主从复制    |
   | used-mem   | 使用内存   | repl-offffset  | 主从复制    |

4. 存储数据库号码

5. 字典大小

6. 过期key

7. 主要数据，以key-value形式存储

8. 结束标识

9. 校验和，就是检查文件是否破损，否者是否被修改



**RDB的优缺点**

**优点**

1. RDB是二进制压缩文件，占用空间小，便于传输（传给slaver）
2. 主进程fork子进程，可以最大化Redis性能，主进程不能太多，Redis的数据不能太大，**复制过程占用多余内存，复制过程中主进程阻塞**

**缺点**

不保证数据完整性，可能会丢失最后一次快照之后更新的所有数据



#####AOF

AOF（append on file）是Redis的另一种持久化方式。Redis默认是不开启的。开启AOF持久化后，Redis将所有对数据库进行**写入的命令（及其参数）**（RESP   Redis Serialization Protocol）记录到AOF文件，以此达到记录数据库状态的目的。（就你做什么我都照这做呗）这样当Redis重启后只要按顺序回放这些命令就恢复到原始状态了。AOF会记录过程，RDB只管结果。



**如何开启AOF持久化**

配置 redis.conf

```shell
# 可通过修改redis.conf配置文件中的appendonly参数开启
appendonly yes
# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dis ./
# 默认的文件名是appendonly.aof,可以通过appendFilename参数修改
appendfilename appendonly.aof
```



**AOF原理**

AOF文件存储的是redis命令，同步命令到AOF文件的整个过程可以分为三个阶段：

命令传播：Redis 将**执行完的命令**、命令的参数、命令的参数个数等信息发送到AOF程序中。

缓存追加：AOF 程序根据接收到的命令数据，将命令转化为网络通讯协议的格式，然后将协议内容追加到服务器的AOF缓存中。

文件写入和保存：AOF缓存中的内容被写入到AOF文件末尾，如果设定的AOF保存条件被满足的话，fsync函数或者fdatasync函数会被调用，将写入的内容真正的保存到磁盘中。



**命令传播**

当一个Redis客户端需要执行命令时，它通过网络连接，将协议文本发送给Redis服务器。服务器在接到客服端的请求之后它会根据协议文本的内容，选择适当的命令函数，并将各个参数从字符串文本转为 Redis 字符串对象(StringObject)。每当命令函数成功执行之后，命令参数都会被传播到AOF程序。

**缓存追加**

当命令被传播到AOF程序之后，程序后根据命令以及命令的参数，将命令从字符串对象转换会原来协议文本。协议文本生成之后，它会被追加到 redis.h/redisServer 结构的 aof_buf 末尾。

**redisServer**结构维持着Redis服务器的状态，**aof_buf**域则保存着所有等待写入AOF文件协议文本(RESP)。

**文件写入和保存**

每当服务器常规任务函数被执行、或者事件处理器被执行时，aof.c/flushAppendOnlyFile 函数都会被调用，这个函数执行一下两个工作：

1. write：根据条件，将 aof_buf 中的缓存写入到AOF文件。（AOF文件是内存对象）
2. save：根据条件，调用 fsync 或 fdatasync 函数，将AOF文件保存到磁盘中。



**AOF保存模式**

Redis 目前支持三种 AOF 保存模式，分别是：

- AOF_FSYNC_NO：不保存

- AOF_FSYNC_EVERYSEC：每一秒保存一次。（默认）

- AOF_FSYNC_ALWAYS：每执行一个命名保存一次。（不推荐，影响效率）



**不保存**（并不代表一直都不持久话，只是触发事件比较苛刻，不然开启AOF干啥）

在这种模式下，每次调用flushAppendOnlyFile 函数，write 都会被执行，但 save 会被忽略过。

在这种模式下，save 指挥在一下任何一种情况中被执行：

1. Redis 被关闭
2. AOF 功能被关闭
3. 系统的写缓存被刷新（可能是缓存已经被写满或者定期保存操作被执行）

注意：这三种情况下的save操作都会引起 **Redis 主进程阻塞**。



**每一秒保存一次**（一个时间段内的缓存，最后一起同步磁盘）

在这种模式中，save 原则上每隔一秒钟就会被执行一次，因为 save 操作是由后台子线程 (fork) 调用的，所以它不会引起服务器主进程阻塞。



**每执行一个命令保存一次**

在这种模式下，每执行完一个命令之后，write和save都会被执行。

另外，对比 AOF_FSYNC_EVERYSEC ，save 操作是由Redis 主进程,所以在SAVE执行期间，主进程会被阻塞，不能接受命令请求。



**AOF保存模式对性能和安全性的影响**

| 模式               | WRITE是否阻塞？ | SAVE是否阻塞？                 | 停机时丢失的数据                                |
| ------------------ | --------------- | ------------------------------ | ----------------------------------------------- |
| AOF_FSYNC_NO       | 阻塞(主进程)    | 阻塞（主进程）                 | 操作系统最后一次对AOF文件触发SAVE操作之后的数据 |
| AOF_FSYNC_EVERYSEC | 阻塞(主进程)    | 不阻塞父进程（子进程执行SAVE） | 一般情况下部超过2秒的数据                       |
| AOF_FSYNC_ALWAYS   | 阻塞(主进程)    | 阻塞(主进程)                   | 最多只丢失一个命令的数据                        |





### Q&A

Linux fork函数作用



如何监控redis的持久化

可以通过info命令查看

![image-20221012165218779](redis持久化.assets/image-20221012165218779.png)






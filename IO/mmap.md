### 传统IO

在开始谈零拷贝之前，首先要对传统的IO方式有一个概念。

基于传统的IO方式，底层实际上通过调用 **read()** 和 **write()** 来实现。

通过 **read()** 把数据从**硬盘**读取到**内核缓冲区**，再复制到**用户缓冲区**；然后再通过write() 写入到 **socket缓冲区**，最后写入网络设备。

<img src="https://fenchuiyun-scw.oss-cn-shanghai.aliyuncs.com/blog/image-20221124103122115.png" alt="image-20221124103122115" style="zoom:50%;" />

整个过程发生了**4次用户态和内核态的上下文切换**和**4次拷贝**，具体流程如下：

1. 用户进程通过 **read()** 方法向操作系统发起调用，此时上下文从用户态转向内核态
2. DMA控制器将数据从硬盘拷贝到读缓冲区
3. CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，**read()** 返回
4. 用户进程通过 **write()** 方法发起调用，上下文从用户态转为 **内核态**
5. CPU将应用缓冲区中数据拷贝到socket缓冲区
6. DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切回用户态，**write()** 返回

![image-20221124104350653](https://fenchuiyun-scw.oss-cn-shanghai.aliyuncs.com/blog/image-20221124104350653.png)

那么，这里指的**用户态**、**内核态**指的是什么？上下文切换又是什么？

简单来说，用户空间指的就是用户空间的运行空间，内核空间就是内核的运行空间。

如果进程运行在内核空间就是内核态，运行在用户空间就是用户态。

为了安全起见，他们之间是互相隔离的，而在用户态和内核态之间的上下文切换也是比较耗时的。

从上面我们可以看到，一次简单的IO过程产生4次上下文切换，这个无疑在高并发场景下会对性能产生较大的影响。

那么什么是**DMA**拷贝呢？

因为对于一个IO操作而言，都是通过CPU发出对应的指令来完成，**但是相比于CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态**。

因此就产生了DMA(Direct Memory Access) 直接内存访问技术，本质上来说他就是一块主板上独立的芯片，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。

但无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。



### 零拷贝

> 零拷贝技术是计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于网络传输文件时节省CPU周期和内存宽带。

那么对于零拷贝而言，并非真的完全没有数据拷贝的过程，只不过是减少用户态和内核态切换的次数以及CPU拷贝的次数。

这里，仅仅有针对性的来谈谈几种常用的零拷贝技术。

##### mmap + write

mmap+write简单来说就是使用 **mmap** 代替了read+write中的read操作，减少了一次CPU拷贝。

**mmap** 主要实现方式是将缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓存区共享，从而减少了从缓冲区到用户缓冲区的一次CPU拷贝。

<img src="https://fenchuiyun-scw.oss-cn-shanghai.aliyuncs.com/blog/image-20221124111408489.png" alt="image-20221124111408489" style="zoom:80%;" />

整个过程发生了**4次用户态和内核态的上下文切换**和**3次拷贝**，具体流程如下：

1. 用户进程通过 **mmap()**方法向操作系统发起调用，上下文从用户态转向内核态
2. DMA控制器把数据从硬盘中拷贝到读缓冲区
3. **上下文从内核态转为用户态，mmap调用返回**
4. 用户进程通过 **write()** 方法发起调用，上下文从用户态转为内核态
5. **CPU将读缓冲区中数据拷贝到socket缓冲区**
6. DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，**write()** 返回

**mmap** 的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。



##### sendfile

相比**mmap**来说，**sendfile** 同样减少了一次CPU拷贝，而且还减少了2次上下文切换。

![image-20221124113644751](https://fenchuiyun-scw.oss-cn-shanghai.aliyuncs.com/blog/image-20221124113644751.png)

**sendfile** 是Linux2.1内核版本后引入的一个系统调用函数，通过使用 **sendfile** 数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝，同时由于使用 **sendfile** 代替了 **read + write** 从而节省了一次系统调用，也就是2次上下文切换。

![image-20221124114055907](https://fenchuiyun-scw.oss-cn-shanghai.aliyuncs.com/blog/image-20221124114055907.png)

整个过程发生了**2次用户态和内核态的上下文切换和3次拷贝**，具体流程如下：

1. 用户进程通过 **sendfile()** 方法向操作系统发起调用，上下文从用户态转向内核态
2. DMA控制器把数据从硬盘拷贝到读缓冲区
3. CPU将读缓冲区数据拷贝到socket缓冲区
4. DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，**sendfile** 调用返回

**sendfile** 方法IO数据对用户空间完全不可见，所以只能适合于完全不需要用户空间处理的情况，比如静态文件服务器。



##### sendfile + DMA Scatter/Gather

Linux2.4内核版本之后对 **sendfile** 做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter/Gather 分散/收集功能。

它将读缓冲区中的数据描述信息——内存地址和偏移量记录到socket缓冲区，由DMA根据这些将数据从读缓冲区拷贝到网卡，相比之前版本少了一次CPU拷贝的过程。

![image-20221124131718536](https://fenchuiyun-scw.oss-cn-shanghai.aliyuncs.com/blog/image-20221124131718536.png)

整个过程发生了**2次用户态和内核态的上下文切换**和**2次拷贝**，其中更重要的是完全没有CPU拷贝，具体流程如下：

1. 用户进程通过**sendfile()** 方法向操作系统发起调用，上下文从用户态转向内核态
2. DMA控制器利用scatter把数据从硬盘中拷贝到读缓冲区离散存储
3. CPU把读缓冲区的文件描述符和数据长度发送到socket缓冲区
4. DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从内核缓冲区拷贝到网卡
5. sendfile() 调用返回，上下文从内核态切换回用户态